<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用功能封装函数for thinkphp5]]></title>
    <url>%2F2018%2F07%2F26%2F%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0for-thinkphp5%2F</url>
    <content type="text"><![CDATA[1,获取微信access_token 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function get_access_token($mp_user, $ref=0)&#123; $redis = new Redis(); // $redis-&gt;rm(&apos;access_token&apos;);die; $access_token = $redis-&gt;get(&apos;access_token_&apos;.$mp_user[&apos;wid&apos;]); $url = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&quot;.$mp_user[&apos;appid&apos;].&quot;&amp;secret=&quot;.$mp_user[&apos;appsecret&apos;]; // dump($access_token);die; // 如果redis中没有缓存或执行强制刷新，重新从微信获取 if (empty($access_token) || $ref == 1) &#123; $json_Res = Request::instance()-&gt;send($url, false, &apos;get&apos;); // 微信返回json $res = json_decode($json_Res, true); Log::log(&apos;access_token&apos;,&apos;request=&apos;.$url.&apos;response=&apos;.$json_Res); // 记录日志 // 规范接口返回值 $data = []; if (isset($res[&apos;access_token&apos;])) &#123; $data[&apos;code&apos;] = 0; $data[&apos;msg&apos;] = &apos;success&apos;; $data[&apos;data&apos;] = [&apos;access_token&apos;=&gt;$res[&apos;access_token&apos;], &apos;cached_time&apos;=&gt;time() + 5400]; &#125;else&#123; $data[&apos;code&apos;] = $res[&apos;errcode&apos;]; $data[&apos;msg&apos;] = $res[&apos;errmsg&apos;]; $data[&apos;data&apos;] = null; &#125; $redis-&gt;rm(&apos;access_token_&apos;.$mp_user[&apos;wid&apos;]); $redis-&gt;set(&apos;access_token_&apos;.$mp_user[&apos;wid&apos;], json_encode($data)); &#125;else&#123; if (isset($access_token[&apos;data&apos;])) &#123; // 如果缓存时间超过1.5小时或没有获取成功，重新从微信获取 if ($access_token[&apos;data&apos;][&apos;cached_time&apos;] &lt;= time()) &#123; $json_Res = Request::instance()-&gt;send($url, false, &apos;get&apos;); // 微信返回json $res = json_decode($json_Res, true); Log::log(&apos;access_token&apos;,&apos;request=&apos;.$url.&apos;response=&apos;.$json_Res); // 记录日志 // 规范接口返回值 $data = []; if (isset($res[&apos;access_token&apos;])) &#123; $data[&apos;code&apos;] = 0; $data[&apos;msg&apos;] = &apos;success&apos;; $data[&apos;data&apos;] = [&apos;access_token&apos;=&gt;$res[&apos;access_token&apos;], &apos;cached_time&apos;=&gt;time() + 5400]; &#125;else&#123; $data[&apos;code&apos;] = $res[&apos;errcode&apos;]; $data[&apos;msg&apos;] = $res[&apos;errmsg&apos;]; $data[&apos;data&apos;] = null; &#125; $redis-&gt;rm(&apos;access_token_&apos;.$mp_user[&apos;wid&apos;]); $redis-&gt;set(&apos;access_token_&apos;.$mp_user[&apos;wid&apos;], json_encode($data)); &#125; &#125;else&#123; $json_Res = Request::instance()-&gt;send($url, false, &apos;get&apos;); // 微信返回json $res = json_decode($json_Res, true); Log::log(&apos;access_token&apos;,&apos;request=&apos;.$url.&apos;response=&apos;.$json_Res); // 记录日志 // 规范接口返回值 $data = []; if (isset($res[&apos;access_token&apos;])) &#123; $data[&apos;code&apos;] = 0; $data[&apos;msg&apos;] = &apos;success&apos;; $data[&apos;data&apos;] = [&apos;access_token&apos;=&gt;$res[&apos;access_token&apos;], &apos;cached_time&apos;=&gt;time() + 5400]; &#125;else&#123; $data[&apos;code&apos;] = $res[&apos;errcode&apos;]; $data[&apos;msg&apos;] = $res[&apos;errmsg&apos;]; $data[&apos;data&apos;] = null; &#125; $redis-&gt;rm(&apos;access_token_&apos;.$mp_user[&apos;wid&apos;]); $redis-&gt;set(&apos;access_token_&apos;.$mp_user[&apos;wid&apos;], json_encode($data)); &#125; &#125; return $redis-&gt;get(&apos;access_token_&apos;.$mp_user[&apos;wid&apos;]);&#125;]]></content>
      <categories>
        <category>工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[thinkphp5常用功能记录]]></title>
    <url>%2F2018%2F07%2F26%2Fthinkphp5%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1,扩展请求类 \think\Request 用于请求微信接口，短信接口等第三方接口。1234567891011121314151617181920212223242526272829303132333435363738/** * 设置当前请求绑定的对象实例 * @access public * @param string $url 请求地址 * @param bool $https 是否https协议 * @param string $method 请求方式 * @param array $data 请求数据 * @return json */ public function send($url, $https=true, $method=&apos;get&apos;, $data=null) &#123; //初始化curl $ch = curl_init($url); //字符串不直接输出，进行一个变量的存储 curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); //https请求 if ($https === true) &#123; //确保https请求能够请求成功 curl_setopt($ch,CURLOPT_SSL_VERIFYPEER,false); curl_setopt($ch,CURLOPT_SSL_VERIFYHOST,false); &#125; //post请求 if ($method == &apos;post&apos;) &#123; curl_setopt($ch,CURLOPT_POST,true); curl_setopt($ch,CURLOPT_POSTFIELDS,$data); &#125; //发送请求 $str = curl_exec($ch); $aStatus = curl_getinfo($ch); //关闭连接 curl_close($ch); if(intval($aStatus[&quot;http_code&quot;])==200)&#123; // return json_decode($str); return $str; &#125;else&#123; return false; &#125; &#125; 使用方法：$res= Request::instance()-&gt;send($url, true, &#39;get&#39;); 2，表单提交时检测变量是否设置。 写法不一样，突然看到另一种写法懵圈了。 用has检测:Request::instance()-&gt;has(&#39;id&#39;,&#39;get&#39;); 助手函数：input(&#39;?get.id&#39;); input(&#39;?post.name&#39;); 3,表单提交用于获取变量。 (1).parm 自动识别多种请求 1234// 获取当前请求的name变量Request::instance()-&gt;param(&apos;name&apos;);// 获取当前请求的所有变量（经过过滤）Request::instance()-&gt;param(); (2) 助手函数12input(&apos;name&apos;);input(&apos;&apos;); 4,]]></content>
      <categories>
        <category>工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[随笔-观念]]></title>
    <url>%2F2018%2F07%2F26%2F%E9%9A%8F%E7%AC%94-%E8%A7%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[看到一篇程序员观念错误的文章，三个观点：1，“别管我，我只想一个人安静地写代码！”很赞同，大多数工作都需要与人打交道。程序员不只是需要确认需求的沟通，接收测试BUG.2，“这不关我的事！”这个深有体会，的确做这些事情可以锻炼到自己，可是待遇不够，被当做苦力，不考虑自己的付出，是对自己的残忍。我理解，从产品经理的角度来讲，我们每个人自己就是一个产品，需要打磨自己的各种能力。3，应该以发展作为第一追求，薪资是其次。片面追求薪资而忽视发展，是短视，不可持续发展。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[随笔-进阶]]></title>
    <url>%2F2018%2F07%2F26%2F%E9%9A%8F%E7%AC%94-%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[之前写的不在了，但也没关系，彼时的境况所确立的东西，现如今已是另一种状态了。 可能我们这一类入门开始就待的小型外包公司的通病，就是基础不扎实，下一阶段对于PHP的函数库，面向对象设计模式，需要重新过一遍。 其次，自己的代码规范再过一遍。 其次，几个类型项目最佳实践。 说白了，就是把各项基础重头再来一遍，shell脚本，nginx,apache,mysql,mvc. 进行几遍迭代，夯实下基础。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[随笔-管理]]></title>
    <url>%2F2018%2F07%2F26%2F%E9%9A%8F%E7%AC%94-%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[其实不只是管理角度，作为一名开发人员，项目进度把控也是自己的一项必修课。 其次，之前总结的不在了，还记得就是，程序员开发工作几年下来，更多的就是业务熟练度和对各种业务逻辑理解上。作为一个管理，自然这也是必须的基础之一，包含行业的最佳实践。 其次，参与项目中去，才能把控开发人员的进度和难点。 其次，每个人的代码规范，管理角度来讲，可以降低团队沟通的成本，优秀的而统一的代码规范，包括变量名等有意义的命名，排版，易于阅读。 再其次，架构设计，结构化编程，面向对象，这是关乎代码质量的。 最后，需求是开发的前提，应该首先处理是否可行，然后才是关注自己的技术领域实现。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发准备工作]]></title>
    <url>%2F2018%2F07%2F25%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[平时虽然是负责开发的，但是准备工作方面也有要做的。 1，个人也可以发布小程序，官方有提供几个分类供个人选择。 2，小程序必须通过微信认证才能使用微信支付。 3，小程序和公众号绑定，可以主体不一致，只是绑定数量有限制。 4,微信支付商户号和小程序主体必须一致]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
